{"version":3,"file":"static/js/pathfinding.worker.89ee917a.worker.js","mappings":"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","sources":["Algorithms/dijkstra.js","Algorithms/astar.js","Algorithms/bfs.js","Algorithms/dfs.js","Algorithms/wall_follower.js","PathfindingVisualizer/pathfinding.worker.js"],"sourcesContent":["export function dijkstra(grid, startNode, endNode) {\n    class PriorityQueue {\n        constructor(comparator = (a, b) => a.distance - b.distance) {\n            this.heap = [null]; // We store keys starting from index 1 for easier math in the `bubbleUp` and `sinkDown` methods.\n            this.comparator = comparator;\n        }\n\n        enqueue(node) {\n            this.heap.push(node);\n            this.bubbleUp();\n        }\n\n        dequeue() {\n            const min = this.heap[1];\n            this.heap[1] = this.heap[this.heap.length - 1];\n            this.heap.pop();\n            this.sinkDown();\n            return min;\n        }\n\n        bubbleUp() {\n            let index = this.heap.length - 1;\n            while (index > 1 && this.comparator(this.heap[Math.floor(index / 2)], this.heap[index]) > 0) {\n                [this.heap[Math.floor(index / 2)], this.heap[index]] = [this.heap[index], this.heap[Math.floor(index / 2)]];\n                index = Math.floor(index / 2);\n            }\n        }\n\n        sinkDown() {\n            let index = 1;\n            while (index * 2 < this.heap.length) {\n                let smallerIndex = index * 2;\n                if (index * 2 + 1 < this.heap.length && this.comparator(this.heap[index * 2 + 1], this.heap[index * 2]) < 0) {\n                    smallerIndex = index * 2 + 1;\n                }\n                if (this.comparator(this.heap[smallerIndex], this.heap[index]) < 0) {\n                    [this.heap[smallerIndex], this.heap[index]] = [this.heap[index], this.heap[smallerIndex]];\n                    index = smallerIndex;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        decreaseKey(node, newDistance) {\n            let index = this.heap.findIndex((element) => element === node);\n            if (index === -1) return;\n            this.heap[index].distance = newDistance;\n            this.bubbleUp();\n            this.sinkDown();\n        }\n\n        contains(node) {\n            return this.heap.includes(node);\n        }\n\n        isEmpty() {\n            return this.heap.length === 1;\n        }\n    }\n\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = new PriorityQueue((a, b) => a.distance - b.distance);\n    unvisitedNodes.enqueue(startNode);\n\n    while (!unvisitedNodes.isEmpty()) {\n        const closestNode = unvisitedNodes.dequeue();\n\n        // If there is a wall, skip it\n        if (closestNode.isWall) continue;\n        // If distance is infinity, we are trapped and should stop\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === endNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n    }\n}\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.isVisited) continue; // Skip if the neighbor is visited\n\n        const newDistance = node.distance + 1;\n        if (newDistance < neighbor.distance) {\n            neighbor.distance = newDistance;\n            neighbor.previousNode = node;\n            if (!unvisitedNodes.contains(neighbor)) {\n                unvisitedNodes.enqueue(neighbor);\n            } else {\n                unvisitedNodes.decreaseKey(neighbor, newDistance);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors;\n}\n\n","export function astar(grid, startNode, endNode) {\n    class PriorityQueue {\n        constructor(comparator = (a, b) => a.distance - b.distance) {\n            this.heap = [null]; // We store keys starting from index 1 for easier math in the `bubbleUp` and `sinkDown` methods.\n            this.comparator = comparator;\n        }\n\n        enqueue(node) {\n            this.heap.push(node);\n            this.bubbleUp();\n        }\n\n        dequeue() {\n            const min = this.heap[1];\n            this.heap[1] = this.heap[this.heap.length - 1];\n            this.heap.pop();\n            this.sinkDown();\n            return min;\n        }\n\n        bubbleUp() {\n            let index = this.heap.length - 1;\n            while (index > 1 && this.comparator(this.heap[Math.floor(index / 2)], this.heap[index]) > 0) {\n                [this.heap[Math.floor(index / 2)], this.heap[index]] = [this.heap[index], this.heap[Math.floor(index / 2)]];\n                index = Math.floor(index / 2);\n            }\n        }\n\n        sinkDown() {\n            let index = 1;\n            while (index * 2 < this.heap.length) {\n                let smallerIndex = index * 2;\n                if (index * 2 + 1 < this.heap.length && this.comparator(this.heap[index * 2 + 1], this.heap[index * 2]) < 0) {\n                    smallerIndex = index * 2 + 1;\n                }\n                if (this.comparator(this.heap[smallerIndex], this.heap[index]) < 0) {\n                    [this.heap[smallerIndex], this.heap[index]] = [this.heap[index], this.heap[smallerIndex]];\n                    index = smallerIndex;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        decreaseKey(node, newDistance) {\n            let index = this.heap.findIndex((element) => element === node);\n            if (index === -1) return;\n            this.heap[index].distance = newDistance;\n            this.bubbleUp();\n            this.sinkDown();\n        }\n\n        contains(node) {\n            return this.heap.includes(node);\n        }\n\n        isEmpty() {\n            return this.heap.length === 1;\n        }\n    }\n\n    const openList = new PriorityQueue((a, b) => a.f - b.f);\n    const closedList = new Set();\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    startNode.h = heuristic(startNode, endNode);\n    startNode.f = startNode.h;\n    openList.enqueue(startNode);\n    while (!openList.isEmpty()) {\n        const currentNode = openList.dequeue();\n        closedList.add(currentNode);\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) {\n            return visitedNodesInOrder;\n        }\n        const neighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of neighbors) {\n            if (closedList.has(neighbor) || neighbor.isWall) continue;\n            const gScore = currentNode.distance + 1;\n            const hScore = neighbor.h || heuristic(neighbor, endNode);\n            neighbor.h = hScore;\n            if (!openList.contains(neighbor)) {\n                openList.enqueue(neighbor);\n                neighbor.distance = gScore;\n                neighbor.f = gScore + hScore;\n                neighbor.previousNode = currentNode;\n            } else if (gScore < neighbor.distance) {\n                neighbor.distance = gScore;\n                neighbor.f = gScore + hScore;\n                neighbor.previousNode = currentNode;\n                openList.decreaseKey(neighbor, neighbor.f);\n            }\n        }\n    }\n    return visitedNodesInOrder;\n}\n\nfunction heuristic(node, endNode) {\n    return Math.abs(node.row - endNode.row) + Math.abs(node.col - endNode.col);\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","export function bfs(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    const queue = [];\n    startNode.distance = 0;\n    queue.push(startNode);\n    while (queue.length !== 0) {\n        const currentNode = queue.shift();\n        if (currentNode.isWall) continue;\n        if (currentNode.distance === Infinity) return visitedNodesInOrder;\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) return visitedNodesInOrder;\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.distance = currentNode.distance + 1;\n            neighbor.previousNode = currentNode;\n            neighbor.isVisited = true;  // Mark as visited here\n            queue.push(neighbor);\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}","export function dfs(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const stack = [startNode];\n    while (stack.length) {\n        const currentNode = stack.pop();\n        if (currentNode.isWall) continue;\n        if (currentNode.distance === Infinity) return visitedNodesInOrder;\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) return visitedNodesInOrder;\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.distance = currentNode.distance + 1;\n            neighbor.previousNode = currentNode;\n            stack.push(neighbor);\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}","export function wallFollower(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    let currentNode = startNode;\n    let previousNode = null;\n    while (currentNode !== endNode) {\n        currentNode.isVisited = true;\n        currentNode.noOfVisits = (currentNode.noOfVisits || 0) + 1; // increment visit count\n        visitedNodesInOrder.push(currentNode);\n        const neighbors = getUnvisitedNeighbors(currentNode, grid);\n        let nextNode = null;\n        for (const neighbor of neighbors) {\n            if (neighbor !== previousNode && !neighbor.isWall) {\n                nextNode = neighbor;\n                break;\n            }\n        }\n        if (nextNode) {\n            nextNode.distance = currentNode.distance + 1;\n            nextNode.previousNode = currentNode;\n            previousNode = currentNode;\n            currentNode = nextNode;\n        } else {\n            if (previousNode) {\n                currentNode = previousNode;\n                previousNode = currentNode.previousNode;\n            } else {\n                break;\n            }\n        }\n    }\n    return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","/* eslint no-restricted-globals: [\"error\", \"never\"] */\n\nimport { dijkstra } from '../Algorithms/dijkstra.js';\nimport { astar } from '../Algorithms/astar.js';\nimport { bfs } from '../Algorithms/bfs.js';\nimport { dfs } from '../Algorithms/dfs.js';\nimport { wallFollower } from '../Algorithms/wall_follower.js';\n\nself.addEventListener('message', (event) => {\n  const { algorithmName, grid, startNode, endNode } = event.data;\n  let algorithm;\n  switch (algorithmName) {\n    case 'dijkstra':\n      algorithm = dijkstra;\n      break;\n    case 'astar':\n      algorithm = astar;\n      break;\n    case 'bfs':\n      algorithm = bfs;\n      break;\n    case 'dfs':\n      algorithm = dfs;\n      break;\n    case 'wallFollower':\n      algorithm = wallFollower;\n      break;\n    default:\n      console.log(\"No such algorithm\");\n      break;\n  }\n  const startTime = performance.now();\n  const visitedNodesInOrder = algorithm(grid, startNode, endNode);\n  const endTime = performance.now();\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n\n  self.postMessage({ visitedNodesInOrder, nodesInShortestPathOrder, startTime, endTime });\n});\n\nfunction getNodesInShortestPathOrder(endNode) {\n  // Implement this function based on your Node class and how you're storing the path\n  // This is just a placeholder implementation\n  const nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","constructor","comparator","arguments","length","undefined","a","b","this","heap","enqueue","node","push","bubbleUp","dequeue","min","pop","sinkDown","index","Math","floor","smallerIndex","decreaseKey","newDistance","findIndex","element","contains","includes","isEmpty","closestNode","isWall","Infinity","isVisited","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","col","row","getUnvisitedNeighbors","neighbor","previousNode","astar","openList","f","closedList","Set","h","heuristic","currentNode","add","has","gScore","hScore","abs","filter","bfs","queue","shift","dfs","stack","wallFollower","noOfVisits","nextNode","self","addEventListener","event","algorithmName","data","algorithm","console","log","startTime","performance","now","endTime","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","postMessage"],"sourceRoot":""}